\section{Implementation}

\subsection{Read Resultant Set of Policies and Analyse Audit Policies}
The basic idea was to implement the use case ''Read Resultant Set of Policies'' (UC01) separately from the use case ''Analysis Audit Policies''. However, during the implementation it quickly became clear that these two use cases could be merged and did not have to be implemented separately. Therefore, both use cases were integrated into one script. The following describes how the two use cases were implemented.

\subsubsection{Result}
Both Use Cases were implemented together in one script. The script follows the following schedule:
\begin{itemize}
    \item Reading and caching of the RSoP
    \item Verification that all defined audit policies are in place
    \item Verification that all defined audit policies are correctly configured
    \item Check if ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' is enabled to prevent conflicts between similar settings
    \item Check if Sysmon is installed and running as a service
    \item Check whether CAPI2 is enabled
\end{itemize}
Each result of the individual steps is then collected in a common XML file. Finally, the environment and files that are no longer needed are deleted, so that only the result XML is available for further processing.

\subsubsection{Approach}
\paragraph{Read Resultant Set of Policies} \ \\
Research was done to read the corresponding audit policy configurations from the system. At the beginning, the approach was to read the required configurations using the command \lstinline|auditpol|. \cite{auditpol} This command can be used to read out and manipulate the currently valid information on the audit policies. However, the manipulation of the audit policies is not necessary within the tool and can be ignored. The command provides exactly the information needed to fulfill this use case:
\begin{lstlisting}[caption=auditpol, language=html]
PS C:\Windows\system32> auditpol /get /category:Logon/Logoff
System audit policy
Category/Subcategory                        Setting
Logon/Logoff
    Logon                                   Success and Failure
    Logoff                                  Success and Failure
    Account Lockout                         No Auditing
    IPsec Main Mode                         No Auditing
    IPsec Quick Mode                        No Auditing
    IPsec Extended Mode                     No Auditing
    Special Logon                           Success and Failure
    Other Logon/Logoff Events               No Auditing
    Network Policy Server                   No Auditing
    User / Device Claims                    No Auditing
    Group Membership                        No Auditing
\end{lstlisting}
Unfortunately, this output is not very ideal for a suitable further processing and analysis of the current configuration. The return value of the command is an ordinary array filled with corresponding strings and therefore the complete array should have been checked for correct content by string comparisons. Furthermore, the command \lstinline|auditpol| does not offer the possibility of remote configuration with regard to an extension of the tool to a whole fleet of computers. For this reason, the idea of building the tool on the basis of this command was rejected.
\\\\
Further research has shown that Microsoft provides a Resultant Set of Policies (RSoP) \cite{RSoP} for reading audit policies. This can also be accessed via a PowerShell command. Microsoft offers the command \lstinline|Get-GPResultantSetOfPolicy| \cite{GetGPResultantSetOfPolicy} for this purpose. This command can be used to generate an XML-based report of the currently valid GPOs. Since traversing an XML-based file via PowerShell proves to be very simple, this variant is preferable to the \lstinline|auditpol| command. After a short test, it quickly became clear that the generated XML provides all necessary information for the further analysis.


\paragraph{Analyse Audit Policies} \ \\
The current configuration of the system's audit policies is then to be evaluated from the temporarily cached file. The basis for this is provided by the JPCERT/CC study (see \ref{JPCertStudy} \nameref{JPCertStudy}).


\subsubsection{Implementation}
% In order to achieve this Use Case, the corresponding Resultant Set of Policies (RSoP) \cite{RSoP} should be read via the PowerShell and temporarily cached in a file. 


\subsection{Script: GetAndCompareLogs}
This section describes the implementation of the ''\nameref{UC03}'' as well as ''\nameref{UC04}''. Both use cases were fulfilled in the PowerShell script ''GetAndCompareLogs''. Here is a description how the use cases were implemented.

\subsubsection{Result}
The script ''GetAndCompareLogs'', where both use cases were implement, runs as follows:
\begin{itemize}
    \item Reading and caching the Event Logs ''System'' \& ''Security''
    \item Filter cached Logs by EventID, multiple EventIDs are grouped together. Found EventIDs are exported as ''CSV''
    \item Checking and caching whether the EventIDs, which are important for the detection of attacks according to JPCERT, can be read out
    \item Export result set of found EventIDs as ''CSV''
    \item Import list of found Event Logs and compare it with the predefined checklist
    \item Result of the comparison is written into an ''XML'' file
    \item Import and compare found Application and Service Logs with predefined checklist
    \item Result of the comparison is written into the same ''XML'' as before
\end{itemize}
The now no longer needed CSV files are deleted. The XML with the result set is now available for any further processing.

\subsubsection{Approach}
\paragraph{Get Event Logs}\ \\
After research was done on how to read out the Event Logs ''System'' and ''Security'' the desicon was made to use to PowerShell command \textbf{Get-EventLog} \cite{Get-EventLogs}. This command allows to read out the whole EventLog by the LogName or also to search after a specific EventID. The first approach was to search for each EventID individually. The EventIDs to search for were taken from the JPCERT Appendix B in the ''Detecting Lateral Movement through Tracking Event Logs'' report. \cite{JPCERTDetectingLateralMovement}. The script run successfully, but the runtime was not practicable. It took over 5 minutes to search for all EventIDs in an Event Log of the size of about 37 000 Logs, or  in other words 300 Kb. The developers than started to calculate the worst case scenario, in this case the worst case scenario is that none of the searched EventIDs is found in the EventLog. There are \textit{n} EventIDs in the checklist and \textit{m} entries in the EventLogs, if no EventID is found, every entry is called \textit{m} times. That results in O(n*m). The developers decided to cache the Event Logs, reducing the runtime to O(m). The cached Logs are then grouped into EventIDs and export into a ''CSV'' file. \ \\
\ \\
To read out the ''Application and Service'' Logs we can not use Get-EventLog. The first approach used the \textbf{Get-WinEvent} \cite{Get-WinEvent} command. The logic stayed the same, read out all events, group and export them into a 'CSV' file. Unfortunately the Get-WinEvent is very slow, it took over 10 minutes to read out just under 6000 logs.
The developers found an other, much quicker command called \textbf{wevtutil} \cite{wevtutil}.
\paragraph{Analyse Found Event Logs}

\subsubsection{Implementation}

