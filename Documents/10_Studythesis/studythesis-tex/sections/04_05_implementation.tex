\section{Implementation}
This sections shows the implementation of the logic. Divided according to the script and its activities, the results of the script are shown first. The second part describes the approach which was taken, which ideas were not implemented and why not. In the third part, the implementation part, the used code is described and explained.
\subsection{Module: GetAndAnalyseAuditPolicies}
The basic idea was to implement the use case ''\nameref{UC01}'' separately from the use case ''\nameref{UC02}''. However, during the implementation it quickly became clear that these two use cases could be merged and did not have to be implemented separately. Therefore, both use cases were integrated into one script module. The following, describes how the two use cases were implemented.

\subsubsection{Result}\label{GetAndAnalyseAuditPoliciesResult}
The script follows the following schedule in the probably most often used \lstinline|-Online| Mode:
\begin{itemize}
    \item Reading and caching of the RSoP which includes the audit settings
    \item Compare the audit settings from the RSoP with the target list so that all defined audit policies are in place
    \item Get all value of the defined audit policies for further analysis
    \item Check if ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' is enabled in registry to prevent conflicts between security settings
    \item Check if Sysmon is installed and running as a service
    \item Check whether CAPI2 is enabled and its log size is appropriate (> 4MB)
\end{itemize}
Each result of the individual steps is collected in hashtables and merged together to be exported to a XML file. Finally, the environment and files that are no longer needed are deleted, so that only the result XML is available for further processing. A result could possibly look like the following listing:
\begin{lstlisting}[caption=Example Result Audit Policy Analysis, language=xml]
<?xml version="1.0" encoding="utf-8"?>
<AuditPolicies>
    <AuditNonSensitivePrivilegeUse>NotConfigured</AuditNonSensitivePrivilegeUse>
    <AuditOtherObjectAccessEvents>NotConfigured</AuditOtherObjectAccessEvents>
    <AuditUserAccountManagement>NotConfigured</AuditUserAccountManagement>
    <AuditKernelObject>NotConfigured</AuditKernelObject>
    <AuditSAM>NotConfigured</AuditSAM>
    <AuditKerberosAuthenticationService>NotConfigured</AuditKerberosAuthenticationService>
    <AuditHandleManipulation>NotConfigured</AuditHandleManipulation>
    <AuditRegistry>NotConfigured</AuditRegistry>
    <AuditProcessTermination>NotConfigured</AuditProcessTermination>
    <AuditFileSystem>NotConfigured</AuditFileSystem>
    <AuditMPSSVCRule-LevelPolicyChange>NotConfigured</AuditMPSSVCRule-LevelPolicyChange>
    <AuditSpecialLogon>NotConfigured</AuditSpecialLogon>
    <AuditFileShare>NotConfigured</AuditFileShare>
    <AuditLogoff>NotConfigured</AuditLogoff>
    <AuditDetailedFileShare>NotConfigured</AuditDetailedFileShare>
    <AuditSensitivePrivilegeUse>NotConfigured</AuditSensitivePrivilegeUse>
    <AuditLogon>NotConfigured</AuditLogon>
    <AuditFilteringPlatformConnection>NotConfigured</AuditFilteringPlatformConnection>
    <AuditProcessCreation>NotConfigured</AuditProcessCreation>
    <ForceAuditPolicySubcategory>Enabled</ForceAuditPolicySubcategory>
    <Sysmon>InstalledAndRunning</Sysmon>
    <CAPI2LogSize>4194304</CAPI2LogSize>
    <CAPI2>EnabledGoodLogSize</CAPI2>
</AuditPolicies>
\end{lstlisting}

\subsubsection{Approach}
\paragraph{Read Resultant Set of Policies} \ \\
Research was carried out to read the corresponding audit policy configurations from the system. At the beginning, the approach was to read the required configurations using the command \lstinline|auditpol|. \cite{auditpol} This command can be used to read out and manipulate the currently valid information on the audit policies. However, the manipulation of the audit policies is not necessary within the tool and can be ignored. The command provides exactly the information needed to fulfill this use case:
\begin{lstlisting}[caption=auditpol, language=PowerShell]
PS C:\Windows\system32> auditpol /get /category:Logon/Logoff
System audit policy
Category/Subcategory                        Setting
Logon/Logoff
    Logon                                   Success and Failure
    Logoff                                  Success and Failure
    Account Lockout                         No Auditing
    IPsec Main Mode                         No Auditing
    IPsec Quick Mode                        No Auditing
    IPsec Extended Mode                     No Auditing
    Special Logon                           Success and Failure
    Other Logon/Logoff Events               No Auditing
    Network Policy Server                   No Auditing
    User / Device Claims                    No Auditing
    Group Membership                        No Auditing
\end{lstlisting}
Unfortunately, this output is not very ideal for a suitable further processing and analysis of the current configuration. The return value of the command is an ordinary array filled with corresponding strings and, therefore, the complete array should have been checked for correct content by string comparisons. Furthermore, the command \lstinline|auditpol| does not offer the possibility of remote configuration with regard to an extension of the tool to a whole fleet of computers. For this reason, the idea of building the tool on the basis of this command was rejected.
\\\\
Further research has shown that Microsoft provides a RSoP \cite{RSoP} for reading audit policies. This can also be accessed via a PowerShell command. Microsoft offers the command \lstinline|Get-GPResultantSetOfPolicy| \cite{GetGPResultantSetOfPolicy} for this purpose. This command can be used to generate an XML-based report of the currently valid GPOs. Since traversing an XML-based file via PowerShell proves to be very simple, this variant is preferable to the \lstinline|auditpol| command. After a short test, it quickly became clear that the generated XML provides all necessary information for the further analysis. Unfortunately, the \lstinline|Get-GPResultantSetOfPolicy| command is not available by default on all systems. However, this command is used and the missing Module: ''GroupPolicy'', which is used to activate the command, will be prerequisite for the script. \cite{GroupPolicy} \cite{RSAT}


\paragraph{Analyse Audit Policies} \ \\
The current configuration of the system's audit policies is then to be evaluated from the temporarily cached file. The basis for this provides section ''\ref{Correlation} \nameref{Correlation}'' based on ''\ref{JPCertStudy} \nameref{JPCertStudy}''.

\clearpage 

\subsubsection{Implementation}
This section describes the implementation of \lstinline|GetAndCheckAuditPolicies| in detail. For this purpose, the following is referred to in section \ref{GetAndAnalyseAuditPoliciesResult} \nameref{GetAndAnalyseAuditPoliciesResult} described schedule. This section is focusing on the \lstinline|-Online| mode but will also cover the other functions which are implemented for a domain based system check.
\\\\
To read the RSoP from the local/currentÂ§ system the command \lstinline|Get-GPResultantSetOfPolicy| is used. The XML that is retrieved is then temporarily cached in the execution path of the script and read in again for further processing. The temporarily cached XML will then be removed.
\begin{lstlisting}[caption=Get-GPResultantSetOfPolicy, language=PowerShell]
try {
    Get-GPResultantSetOfPolicy -ReportType Xml -Path  $PathRSoPXML | Out-Null
}
catch {
    Write-Host "Necessary Module: `'GroupPolicy`' is not provided 
                    within this system" -ForegroundColor Red
    return
}

if ([System.IO.File]::Exists($PathRSoPXML)) {
    [xml]$RSoPResult = Get-Content $PathRSoPXML
}
\end{lstlisting}
\vspace{0.5cm}
\begin{multicols}{2}
    \ \\\\\\ \
    The generated XML (RSoP) is an extraction of the GPOs and contains only the configurations set from them.
    Afterwards the analysis begins and the entries are searched in the XML file, in which the required configurations for the ''Advanced Audit Policies'' are stored (see figure \ref{fig:AdvancedAuditPolicies}).
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.7\linewidth]{assets/GetAndCheckAuditPolicies/advancedauditpolicies.png}
        \caption{GPO - Advanced Audit Policies}\label{fig:AdvancedAuditPolicies}
    \end{figure}
\end{multicols}
The function \lstinline|CompareToTargetList| searches for missing audit settings. It iterates over the queried \lstinline|AuditSettings| and searches for missing configurations. Any missing setting will be written in a hashtable \lstinline|result| for further processing.
\begin{lstlisting}[caption=CompareToTargetList: Search missing configurations, language=PowerShell]
Function CompareToTargetList ([Hashtable] $AuditSettings, [Array] $TargetAuditSettings) {
    $Result = @{}    
    foreach ($TargetAuditSetting in $TargetAuditSettings) {
        if ($AuditSettings.keys -notcontains $TargetAuditSetting) {
            $Result.Add(($TargetAuditSetting -replace (" ")), "NotConfigured")
        }
    }
    return $Result
}
\end{lstlisting}

\clearpage
After checking for missing configurations, all values of the set settings are gathered for further processing.
\begin{lstlisting}[caption=GetAuditSettingValues: Get configured audit settings from RSoP, language=PowerShell]
foreach ($AuditSetting in $AuditSettings.GetEnumerator()) {
    if ($TargetAuditSettings -notcontains $AuditSetting.Name) {
        continue
    }
    if ($AuditSetting.Value -and $AuditSetting.Name) {
        try {
            $AuditSettingValue = $AuditSetting.Value
        }
        catch {
            $AuditSettingValue = 0
        }
        $AuditSubcategoryName = $AuditSetting.Name 
        switch ($AuditSettingValue) {
            NoAuditing {  
                $AuditSettingValueString = "NoAuditing"
                continue
            }
            Success {
                $AuditSettingValueString = "Success"
                continue
            } 
            Failure {
                $AuditSettingValueString = "Failure"
                continue
            }
            SuccessAndFailure {
                $AuditSettingValueString = "SuccessAndFailure"
                continue
            }
            Default { continue }
        }
        $Result.Add(($AuditSubcategoryName -replace (" ")), $AuditSettingValueString)
    }    
}
\end{lstlisting} \ \\
After gathering of the values, the next step is to verify if the setting ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' is enabled as considered in section ''\ref{DomainModelAuditPolicy} \nameref{DomainModelAuditPolicy}''. This had to be solved via the registry, because this information is not available in the RSoP.

\begin{lstlisting}[caption=GetRegistryValue,language=PowerShell]
Function GetRegistryValue([String] $Path, [String] $Name) {
    return Get-ItemProperty -Path $Path -Name $Name -ErrorAction Stop
}
\end{lstlisting} \ \\
The registry entry is captured in a separate function to provide the possibility for tests. This function is called with the following parameter \cite{ForceAudit} to get the searched registry entry:

\begin{lstlisting}[language=PowerShell]
$Path = "HKLM:\System\CurrentControlSet\Control\Lsa"
$Name = "SCENoApplyLegacyAuditPolicy"
\end{lstlisting}


\begin{lstlisting}[caption=Function IsForceAuditPolicyEnabeled, language=PowerShell]
Function IsForceAuditPolicyEnabeled ([Object] $AuditPolicySubcategoryKey) {
    $result = @{}

    if ($auditPolicySubcategoryKey) {
        if ($auditPolicySubcategoryKey.SCENoApplyLegacyAuditPolicy -eq 1) {
            $result.Add("ForceAuditPolicySubcategory", "Enabled")
            return $result
        }
        else {
            $result.Add("ForceAuditPolicySubcategory", "Disabled")
            return $result
        }
    }
    else {
        $result.Add("ForceAuditPolicySubcategory", "NotDefined")
        return $result
    }
}
\end{lstlisting}\ \\
The next step is to check if Sysmon as a service is installed (also not contained in the RSoP) and, if so, is it running or not. Since a service can be renamed to hide it from the bad guys, the \lstinline|Get-Service| command cannot make a 100\% statement about whether the service is actually installed. For this reason the description of the service is queried, which does not change while renaming. \cite{Sysmon1}
\begin{lstlisting}[caption=Function IsSysmonInstalled, language=PowerShell]
Function IsSysmonInstalled {
    $Service = Get-WmiObject win32_service -Filter "Description = 'System Monitor service'"
    $Result = @{}

    if ($Service) {
        if ($Service.State -ne "Running") {
            $Result.Add("Sysmon", "InstalledNotRunning")
            return $Result
        }
        else {
            $Result.Add("Sysmon", "InstalledAndRunning")
            return $Result
        }
    }
    else {
        $Result.Add("Sysmon", "NotInstalled")
        return $Result
    }
}
\end{lstlisting}

\clearpage

As a last step, the online mode is checking whether CAPI2 is enabled and has the right minimum log size of 4MB. The decision for 4MB is mentioned in the section ''\ref{CAPI2} \nameref{CAPI2}''. Unfortunately, this information is also not available via the RSoP. Therefore, the command \lstinline|wevtutil| is used to query CAPI2 in the event log. The reason for this is that CAPI2 can only be enabled via the Event Viewer. \cite{CAPI2} In order to enable testing here as well, a Get function for the event log entry has been created.

\begin{lstlisting}[caption=Function GetCAPI2, language=PowerShell]
Function GetCAPI2 {
    return [xml](wevtutil gl Microsoft-Windows-CAPI2/Operational /f:xml)
}
\end{lstlisting}\ \\
The log size is stored in the Windows system as mebibyte (MiB). This is the reason for defining the initial log size to \lstinline|4194304|. The following conversion from 4 MB to mebibyte should make it clear:
\begin{center}
    \textsc{4 MB = 4 $\cdot$ 1024 $\cdot$ 1024 Bytes = 4194304 Bytes }
\end{center}
\begin{lstlisting}[caption=Function IsCAPI2Enabled, language=PowerShell]
Function IsCAPI2Enabled([xml] $capi2, [uint32] $requiredLogSize) {
    $capi2Enabled = $capi2.channel.enabled
    $currentLogSize = $capi2.channel.logging.maxsize -as [uint32]
    $result = @{}

    if ($requiredLogSize -lt 4194304) {
        $requiredLogSize = 4194304
    }

    if ($capi2Enabled -eq "true" -and $currentLogSize -ge $requiredLogSize) {
        $result.Add("CAPI2", "EnabledGoodLogSize")
        $result.Add("CAPI2LogSize", "$currentLogSize")
    }
    elseif ($capi2Enabled -eq "true" -and $currentLogSize -lt $requiredLogSize) {
        $result.Add("CAPI2", "EnabledBadLogSize")
        $result.Add("CAPI2LogSize", "$currentLogSize")
    }
    else {
        $result.Add("CAPI2", "Disabled")
    }
    return $result
}  
\end{lstlisting}
All temporary files are removed at the end of this script.
\clearpage

To fulfill \nameref{UC08} (see section \ref{UC08}) two functions where created to gather the advanced audit settings from group policies. One for gathering information about a specific group policy (\lstinline|GetDomainAuditPolicy|) and the other for all group policies (\lstinline|GetAllDomainAuditPolicies|). To achieve this, the information is gathered from the System Volume (SYSVOL) where all group policies remain in an active directory network. The audit settings of each group policy, remaining in SYSVOL, are stored as a CSV. This CSV is imported and each setting is gathered for further analysis. Like within the online mode, after doing so the hashtable is returned and filled with the missing audit settings. 

\begin{lstlisting}[caption=Function GetDomainAuditPolicy, language=PowerShell]
Function GetDomainAuditPolicy ([String] $PolicyName) {
    $PolicyCSV = CheckDomainAndPolicy $PolicyName

    if ([System.IO.File]::Exists($PolicyCSV)) {
        Write-Host "Get audit settings from group policy: `'$PolicyName`'"
        $AuditSettings = @{}
        $Policy = Import-Csv $PolicyCSV -Encoding UTF8

        foreach ($Element in $Policy) {
            $AuditSettings.Add(($Element.Subcategory -replace (" ")), $Element."Setting Value")
        }  
        return $AuditSettings
    } else {
        Write-Host "For this Group Policy exist no auditing definition" 
        return
    }
}
\end{lstlisting}

To analyse all group policies the function \lstinline|GetDomainAuditPolicy| is called for each group policy and a hashtable, with the name of the group policy as the key and the settings as the value, is filled and returned.
\begin{lstlisting}[caption=Function GetAllDomainAuditPolicies, language=PowerShell]
Function GetAllDomainAuditPolicies {
    try {
        $GPOs = Get-GPO -all | Select-Object DisplayName, Id
    }
    catch {
        Write-Host "Your system is not associated with an Active Directory domain or forest"
        return
    }
    
    $AuditSettingsPerPolicy = @{}
    $AuditSettings = @{}

    foreach ($GPO in $GPOs) {
        $AuditSettings = GetDomainAuditPolicy $GPO.DisplayName
        $AuditSettingsPerPolicy.Add($GPO.DisplayName, $AuditSettings)
    }
    
    return $AuditSettingsPerPolicy
}
\end{lstlisting}

\clearpage
In addition to capture all audit settings of the group policies, the setting ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' is captured as well. If this setting is enabled in the group policy, it will remain in \lstinline|GptTmpl.inf| in \lstinline|SecEdit| in the SYSVOL-path of each policy.


\begin{lstlisting}[caption=Function IsForceAuditPolicyDomainEnabeled, language=PowerShell]
Function IsForceAuditPolicyDomainEnabeled ([String] $PolicyName) {
    $Domain = Get-WmiObject Win32_ComputerSystem -ComputerName "localhost" 
                  | Select-Object -ExpandProperty Domain

    $PolicyId = Get-GPO -Name $PolicyName | Select-Object -ExpandProperty id
    
    $SecEditPath =  "\\$Domain\SYSVOL\$Domain\[...]\Windows NT\SecEdit\GptTmpl.inf"
    $ForceAuditPolicyEnabled = "MACHINE\[...]\SCENoApplyLegacyAuditPolicy=4,1"
    $ForceAuditPolicyDisabled = "MACHINE\[...]\SCENoApplyLegacyAuditPolicy=4,0"
    $AuditSettings = @{}

    if (Test-Path $SecEditPath) {
        $RegistryKeyValue = Get-Content $SecEditPath

        if ($RegistryKeyValue -contains $ForceAuditPolicyEnabled) {
            $AuditSettings.Add("ForceAuditPolicySubcategory", "Enabled")
        } elseif ($RegistryKeyValue -contains $ForceAuditPolicyDisabled) {
            $AuditSettings.Add("ForceAuditPolicySubcategory", "Disabled")
        } else {
            $AuditSettings.Add("ForceAuditPolicySubcategory", "NotDefined")
        }
    } 
    return $AuditSettings
}
\end{lstlisting}

\clearpage

\subsection{Module: GetAndCompareLogs}
This section describes the implementation of the ''\nameref{UC03}'' as well as ''\nameref{UC04}''. Both use cases were fulfilled in the PowerShell script ''GetAndCompareLogs''. Here is a description how the use cases were implemented.

\subsubsection{Result} \label{ResultSetGetAndCompareLogs}
The script ''GetAndCompareLogs'', where both use cases were implemented, runs as follows:
\begin{itemize}
    \item Reading and caching the Event Logs ''System'' \& ''Security''
    \item Filter cached Logs by EventID, group EventIDs that occur more than once. Found EventIDs are exported as ''CSV''
    \item Checking and caching whether a list of EventIDs from ''Application and Service'' Logs can be read out
    \item Export result set of found EventIDs as ''CSV''
    \item Import list of found Event Logs and compare it with the predefined checklist
    \item Result of the comparison is written into an ''XML'' file
    \item Import and compare found Application and Service Logs with predefined checklist
    \item Result of the comparison is written into the same ''XML'' as before
\end{itemize}
The now no longer needed CSV files are deleted. The XML with the result set is now available for any further processing.  A result could possibly look like the following listing:
\begin{lstlisting}[caption=Example Result Audit Policy Analysis, language=xml]
    <?xml version="1.0"?>
    <Logs>
        <EventLogsID>
            <6>present</6>
            <21>missing</21>
            <24>missing</24>
            <102>missing</102>
            <104>missing</104>
            <106>missing</106>
            <201>missing</201>
            <4624>present</4624>
            <4634>present</4634>
            <4648>present</4648>
            <4656>present</4656>
            ...
        </EventLogsID>
        <AppAndServID>
            <106>present</106>
            <200>present</200>
            <129>present</129>
            <201>present</201>
            <102>present</102>
            <6>missing</6>
            <169>missing</169>
            <21>present</21>
            <24>present</24>
        </AppAndServID>
    </Logs>
\end{lstlisting}


\subsubsection{Approach}
\paragraph{Get Event Logs}\ \\
After research was done on how to read out the Event Logs ''System'' and ''Security'' the desicon was made to use to PowerShell command\lstinline|Get-EventLog| \cite{Get-EventLogs}. This command allows to read out the whole EventLog by the LogName or also to search after a specific EventID. The first approach was to search for each EventID individually. The EventIDs to search for were taken from the JPCERT/CC Appendix B in the ''Detecting Lateral Movement through Tracking Event Logs'' report. \cite{JPCERTDetectingLateralMovement}. The script ran successfully, but the runtime was not practicable. It took over 5 minutes to search for all EventIDs in an Event Log of the size of about 37 000 Logs, or  in other words 300 Kilobyte (KB). The developers than started to calculate the worst case scenario, in this case the worst case scenario is that none of the searched EventIDs is found in the EventLog. There are \textit{n} EventIDs in the checklist and \textit{m} entries in the EventLogs, if no EventID is found, every entry is called \textit{m} times. That results in O(n*m). The developers decided to cache the Event Logs, reducing the runtime to O(m). The cached Logs are then grouped into EventIDs and export into a ''CSV'' file. \ \\
\ \\
To read out the ''Application and Service'' Logs we can not use Get-EventLog. The first approach used the \lstinline|Get-WinEvent| \cite{Get-WinEvent} command. The logic stayed the same, read out all events, group and export them into a 'CSV' file. Unfortunately the Get-WinEvent is very slow, it took over 10 minutes to read out just under 6000 logs.
The developers found an other, much quicker command called \lstinline|wevtutil| \cite{wevtutil}. Unfortunately it is not quite simple to read out all Logs, for that reason each EventID will be searched if it appeared. Unlike Get-EventLog, this is not a problem because the command is faster, the EventIDs are more likely to occur and the amount of Logs is smaller. On the testing environment with a machine with 4 Gigabyte (GB) Ram and an Intel Xeon E5 with 2 cores it took about 10 seconds to check for 9 EventIDs in 15 000 Log entries. If and EventID was found it was added to an ArrayList, after all IDs are checked the file is exported as a 'CSV'.
\paragraph{Analyse Found Event Logs} \ \\
To analyse the occurred EventIDs the two generated ''CSV'' files are imported into the PowerShell script. The respective checklists, which are based on the \nameref{JPCertStudy}, are embedded in the script. Each id from the checklist is checked if it is present in the respective CSV file. Is this the case, the id is added to the XML-file and marked as present. Did the id no occur in the it will be added and marked as missing. The file looks like the example in ''\nameref{ResultSetGetAndCompareLogs}'' shown.
\clearpage

\subsubsection{Implementation}
This section describes the implementation of \lstinline|GetAndCompareLogs| in detail. For this purpose, the following is referred to in the section ''\ref{ResultSetGetAndCompareLogs} \nameref{ResultSetGetAndCompareLogs}'' described schedule.
\\\\
The first step is to read out the ''System'' and ''Security'' Logs. To achieve this goal the command \lstinline|Get-EventLog| is used in the first part of the function \lstinline|GetEventLogsAndExport|. \begin{description}
    \item[Note] The code has been adapted for better readability and easier understanding
    \end{description}
\begin{lstlisting}[caption=Function GetEventLogsAndExport Part 1, language=PowerShell]
    $logNames = @("System", "Security")
    $eventLogs = New-Object System.Collections.ArrayList

    Function GetEventLogsAndExport{
        foreach($log in $logNames){
        $eventLogs += Get-EventLog -LogName $log
        }
    ...
\end{lstlisting}
The second part of the function filters the EventIDs from the chaced logs. Subsequently, multiple EventIDs are grouped together.
\begin{lstlisting}[caption=Function GetEventLogsAndExport Part 2, language=PowerShell]
    $currentFolder = (Resolve-Path .\).Path
    $exportEventLogsIntoCSV=$currentFolder + "\myeventlogs.csv"

    $eventLogs| Select EventID -Unique |Export-CSV $exportEventLogsIntoCSV -NoTypeInfo -Encoding UTF8
    }
\end{lstlisting}
After the export the function \lstinline|GetApplicationAndServiceLogs| is called. As before, the function is divided into two parts, first how to get the data. The same procedure is used three times, for the ''TaskScheduler'', ''WindowsRemoteManagement'' and ''LocalSessionManager''. Due to the fact that the code is very similarly it is only shown once. To search for the EventIDs  \lstinline|wevtutil| is used.
\begin{lstlisting}[caption=Function GetApplicationAndServiceLogs Part 1, language=PowerShell]
    $appAndServLogs = New-Object System.Collections.ArrayList
    $idsForTaskScheduler = ("106", "200", "129", "201", ...

    $appAndServLogs += "EventID"

    Function GetApplicationAndServiceLogs{
    
    foreach($id in $idsForTaskScheduler){
    if(wevtutil qe Microsoft-Windows-TaskScheduler/Operational /q:"*[System[(EventID="$id" )]]" /uni:false /f:text){
        $appAndServLogs += $id
         }
    }
    ...
\end{lstlisting}
\clearpage
After all three Logs were checked and all found EventIDs were added, the information is exported into a ''CSV''-file.
\begin{lstlisting}[caption=Function GetApplicationAndServiceLogs Part 2, language=PowerShell]
    $exportApplicationAndServiceLogsIntoCSV = $currentFolder + "\myapplicationandservicelogs.csv"

    $appAndServLogs | Out-File -FilePath $exportApplicationAndServiceLogsIntoCSV
    }
\end{lstlisting}
The next point on the list is importing the found ''EventLogs'' and ''Service And Application'' Logs. Due to the similarity we only show one code.
\begin{lstlisting}[caption=Function ImportCompareExport, language=PowerShell]
    
    $eventLogIdsToCheck = (6, 21, 24, 102, 104, 106, 129, ...

    # Create XML "resultOfEventLogs.xml"

    $importEventLogs = $exportEventLogsIntoCSV
    $myEventLogs = Import-Csv $importEventLogs -Encoding UTF8

    Function ImportCompareExport{
        foreach($id in $eventLogIdsToCheck){
           if($myEventLogs | where {$_.EventID -eq $id}){
            # Write to XML with value "present"
                }
                else{
                    # Write to XML with value "missing"
                }
        }
    }
    # Close XML
\end{lstlisting}
The same happens with the ''App and Service'' Logs in the \lstinline|GetApplicationAndServiceLogs| function. All temporary files are removed at the end of this script.
\clearpage
\subsection{Module: Visualize}
In this script the ''\nameref{UC05}'' is implemented here the description how it was done.
\subsubsection{Result} \label{resultVisualize}
The script ''\nameref{UC05}'' runs as follows:
\begin{itemize}
    \item Create Portable Document Format (PDF) at given folder and ''open'' it
    \item Import audit policies and compare them to a given checklist, result is written and visualized in a table
    \item Check which attack tool categories can be detected with the current audit guidelines and which cannot
    \item Import the found EventLogs and check if the important EventIDs, according to JPCERT/CC, are found
    \item ''Close'' PDF-document
\end{itemize}
The resulting PDF looks something like this: \ \\
\ \\
\textbf{AuditPolicies}
\begin{table}[H]
    \centering
    \begin{tabular}{| p{4.5cm} |  p{4cm} | p{4cm} | p{2.5cm}|} \hline
        Aduit Name & Target & Actual & Prio\\ \hline
        AuditNonSensitivePrivilege & SuccessAndFailure &\cellcolor{green} SuccessAndFailure & High\\ \hline
        AuditProcessTermination & Success &\cellcolor{darkgreen} SuccessAndFailure & Medium \\ \hline
        AuditSAM & SuccessAndFailure &\cellcolor{red} NotConfigured & Low\\ \hline
        ... & ... & ... &\\ \hline
    \end{tabular}
\end{table}\ \\
With this policies it is possible to detect X out of 14 attack categories \ \\
The following attack categories cannot be detected with certainty: \\
... \ \\
\ \\
\textbf{WindowsLogs}
\begin{table}[H]
    \centering
    \begin{tabular}{| p{8cm} |  p{8cm} |} \hline
        EventID6 & present \\ \hline
        EventID104 & missing \\ \hline
        ... & ... \\ \hline
    \end{tabular}
\end{table}
\subsubsection{Approach}
At first, the developers considered using ''PowerBI'' \cite{PowerBI}, like Jessica Payne uses it in ''WEFFELS''. But after a short trial they decided that the tool was too overpowered for their purpose. Also, they did not like that the user would have to install a third-party tool to analyse his data. The Dynamic Link Library (DLL) ''iTextSharp'', originally a C\# library, allows to generate a PDF directly from the code, which can also be used in PowerShell. This variant is not very versatile and it is difficult to create an appealing design, but it is enough for now. 

\subsubsection{Implementation}
This section describes the implementation of \lstinline|Display missing or wrong system configuration| in detail. For this purpose, the following is referred to in section ''\ref{resultVisualize} \nameref{resultVisualize}'' described schedule. \\\\
The iTextSharp.dll and the functions from \lstinline|PowerShell-PDF| \cite{PowerShell-PDF} were imported. The first step is to create a PDF-document and ''open'' it. For this purpose the function \lstinline|OpenPDF| was created:
\begin{lstlisting}[caption=Function OpenPDF, language=PowerShell]
function OpenPDF{
    $pdf = New-Object iTextSharp.text.Document 
    New-PDF -Document $pdf -File #export path
    $pdf.Open()
   }
\end{lstlisting}
The function \lstinline|WriteAuditPolicies| then compares the found audit policies and display the ones who are incorrectly. It will call two other functions, \lstinline|CreateAddCellWithColor| and \lstinline|CreateAddCell|.
\begin{lstlisting}[caption=Functions WriteAuditPolicies \& CreateAddCellWithColor \& CreateAddCell, language=PowerShell]
function WriteAuditPolicies{
    $auditChecklist = @{AuditLogon = @("Success", "Medium"; ...)}
    $incorrectAudits = @() # will be returned for later use
    [xml] auditXml = Get-Content $auditPath
    $myAudits = $auditXml.AuditPolicies.ChildNodes
    foreach ($audit in $myAudits) {
        $localName = $audit.LocalName
        CreateAddCell $localName # Display auditname into cell

        $checkaudit = $auditChecklist[$localName]
        $checkauditvalue = $checkaudit[0] # Correct setting
        $checkauditprio = $checkaudit[1] # Priority of audit

        if ($audit.InnerXml -eq $checkauditvalue) { # Checks if audit values are equal
            CreateAddCell $checkauditvalue # Displays correct audit value
            CreateAddCellWithColor $audit.InnerXml 0 255 0 
            # Displays actual audit value into cell, color green  
        }
        elseif ($audit.InnerXml.startswith("Succ") #checks if audit is ''overpowered''
        -and $checkauditvalue -eq "Success") {
            CreateAddCell $checkauditvalue # Displays correct audit value
            CreateAddCellWithColor $audit.InnerXml 0 106 0 
            # Displays actual audit value into cell, color darkgreen
        }
        else { #audit is wrong
            CreateAddCell $checkauditvalue # Displays correct audit value
            CreateAddCellWithColor $audit.InnerXml 255 0 0 
            #Displays actual audit value into cell, color red
            $incorrectAudits += $audit.LocalName
        }
        CreateAddCell $checkauditprio # Displays audit priority into cell
    }
    return $incorrectAudits
}






function CreateAddCellWithColor($content, $R, $G, $B) {
    # Create iTextSharp.text.Paragraph and add content
    # Create  iTextSharp.text.pdf.PdfPCell with paragraph and set backgroundcolor $R $G $B
    # Add Cell to Table
    }

function CreateAddCell($content) {
        # Create iTextSharp.text.Paragraph and add content
        # Create  iTextSharp.text.pdf.PdfPCell with paragraph
        # Add Cell to Table
}
\end{lstlisting}
Now that the ''Import audit policies and compare them to a given checklist, result is written and visualized in a table'' is done, it is possible to check which attack tool categories can be detected with the current audit settings. For that purpose, the function \lstinline|ToolsCanBeDetected| was created. This function relies on the return of the \$incorrectAudits.
\begin{lstlisting}[caption=Function ToolsCanBeDetected, language=PowerShell]
    function ToolsCanBeDetected($incorrectAudits){
        [xml] $auditsByCategorie = Get-Content "$PSScriptRoot\AuditByCategorie.xml"
        $notDetectableCategories = @()
        $causingAudit = @()

        $Categories = $auditsByCategorie.Category.ChildNodes
        foreach ($Category in $Categories) {
            [int]$checknr = 0
            foreach ($incorrectAudit in $incorrectAudits) {
                if ($Category.ChildNodes.InnerXml -contains $incorrectAudit) {
                    $checknr += 1
                    $causingAudit += $incorrectAudit
                }
            }
        
            if ($checknr -gt 0) {
                $notDetectableCategories += $Category.LocalName + "(" + $causingAudit + ")"
            }

        # Output of the not detectable categories and the causing audits    
    }
\end{lstlisting}
The next step is to display the found EventLogs and if they are missing or present. Therefore two tables, one for the WindowsLogs and one for the Application And Service Logs, are created. Because these two tables are created the same way, only one case is shown. Hence, the function \lstinline|WriteEventLogs| was created.
\begin{lstlisting}[caption=Function ToolsCanBeDetected, language=PowerShell]
    function WriteEventLogs { 
        [xml] $eventxml = Get-Content # importPath
        # Add Title
        $eventsWindows = $eventxml.Logs.EventLogsID.ChildNodes
        $result = @()
        foreach ($event in $eventsWindows) {
            $result += $event.LocalName
            $result += $event.InnerXml
        }
        #Add result to table
    }
\end{lstlisting}
As a final task, all these function have to be called in the right order, and the opened PDF has to be closed. For this case, the simple function \lstinline|VisualizeAll| was created:
\begin{lstlisting}[caption=Function VisualizeAll, language=PowerShell]
    function WriteEventLogs { 
        $pdf = OpenPDF $exportFolder
        $incorrectAudits = WriteAuditPolicies $exportFolder
        ToolCanBeDetected $incorrectAudits
        WriteEventLogs $exportFolder
        $pdf.Close()
    }
\end{lstlisting}

\clearpage

\subsection{Main Script: SRI}
The aim of the main script is to supply the user with various procedures to evaluate the readiness of audit policies and/or event logs. However, the user is not meant to use single functions provided by the modules because most function provide just a metaset of data in order to make a statement of the readiness. For this reason, the main script is able to be called with various parameter for the diffrent procedures. Moreover, the user gets a help functionality (via PowerShells common \lstinline|Get-Help|) to provide an overview of parameter combinations.
\subsubsection{Result}
The various procedures/modes provided by the main script, with eventual additional parameter, are:
\begin{itemize}
    \item \textbf{\textit{-Online, -Offline, -GroupPolicy and -AllGroupPolicies}}
\end{itemize}
\begin{lstlisting}[caption=]
PS C:\>./sri.ps1 [-Online] [-OnlineExportPath <String>] [-CAPI2LogSize <Int32>]

PS C:\>./sri.ps1 [-Offline] [[-AuditPolicies]] [[-EventLogs]] [-ImportPath] <String> 
                       [[-ExportPath] <String>] [-CAPI2LogSize <Int32>]

PS C:\>./sri.ps1 [-GroupPolicy] [-GroupPolicyName] <String>

PS C:\>./sri.ps1 [-AllGroupPolicies]
\end{lstlisting}
\vspace{0.5cm}
\textsc{\textbf{Note:}}\textit{ Mandatory parameter are \underline{underlined}.}
\vspace{0.5cm}
\begin{tcolorbox}
    \paragraph{\underline{-Online}} \ \\\\
    The current system which is calling the script will be checked on its readiness.
    \vspace{0.3cm}
    \begin{center}
        \textsc{Parameter}
    \end{center}
    \vspace{-0.5cm}
    \begin{table}[H]
        \def\arraystretch{2}
        \centering
        \begin{tabular}{ p{4cm}  p{10cm} }  \hline
            \textbf{No parameter} & The result PDF will be saved to the current path \\ \hline
            \textbf{-OnlineExportPath} & The result PDF will be saved to this path \\ \hline
            \textbf{-CAPI2LogSize} & Definition of the CAPI2 log size suitable for the environment. By default this value is set to 4MB as recommended from Microsoft \cite{CAPI2} \\ \hline
        \end{tabular}
    \end{table}
\end{tcolorbox}

\begin{tcolorbox}
    \paragraph{\underline{-Offline}} \ \\\\ Some system will be checked on its readiness - by default audit policies and event log are analysed. Export files of this system are required.
    \vspace{0.3cm}
    \begin{center}
        \textsc{Parameter}
    \end{center}
    \vspace{-0.5cm}
    \begin{table}[H]
        \def\arraystretch{2}
        \centering
        \begin{tabular}{ p{4cm}  p{10cm} }  \hline
            \textbf{\underline{-ImportPath}} & Defines where the required files rsop.xml\footnote{XML-Export of Resultant Set of Policy \cite{RSoP}}, windowslogs.csv\footnote{Export of }, appandservlogs.csv\footnote{Export of } remain for analysis. \\ 
            & The result PDF will be saved to the current path \\ \hline
            \textbf{-AuditPolicies} & Checks only the audit policies. \\
            & The result PDF will be saved to the current path \\ 
            & \textbf{\underline{-ImportPath}} requires rsop.xml \\\hline
            \textbf{-EventLogs} & Checks only the event logs \\
            & The result PDF will be saved to the current path \\ 
            & \textbf{\underline{-ImportPath}} requires windowslogs.csv and appandservlogs.csv\\\hline
            \textbf{-ExportPath} & The result PDF will be saved to this path \\ \hline
            \textbf{-CAPI2LogSize} & Definition of the CAPI2 log size suitable for the environment. By default this value is set to 4MB as recommended from Microsoft \cite{CAPI2} \\ \hline
        \end{tabular}
    \end{table}
\end{tcolorbox}

\begin{tcolorbox}
    \paragraph{\underline{-GroupPolicy}} \ \\\\ Audit policies from a specific group policy are analysed.
    \vspace{0.3cm}
    \begin{center}
        \textsc{Parameter}
    \end{center}
    \vspace{-0.5cm}
    \begin{table}[H]
        \def\arraystretch{2}
        \centering
        \begin{tabular}{ p{4cm}  p{10cm} } \hline
            \textbf{\underline{-GroupPolicyName}} & The name of the group policy to be analysed \\ \hline
        \end{tabular}
    \end{table}
\end{tcolorbox}

\begin{tcolorbox}
    \paragraph{\underline{-AllGroupPolicies}} \ \\\\
    All audit policies from every group policy in the current domain are analysed.\\
    The result PDF will be saved to the current path
\end{tcolorbox}

\subsubsection{Approach}
Users should not have to call the individual functions from the PowerShell modules. For this reason, the idea was to provide a main script which defines several modes to call with appropriate parameter. Each mode has a predefined procedure of function calls which will create a result PDF. In addition, the script should be delivered with a integrated help functionality to supply a on-demand overview of all possible script modes and its parameter. 

\subsubsection{Implementation}
To get a better understanding how each mode proceeds, this section describes the source code in form of activity diagrams. The activity diagrams are an overview and contain the core of each mode.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{assets/modes/online.png}
    \caption{Online Mode}
\end{figure}
\begin{enumerate}
    \item Get the audit policies from RSoP
    \item Analyse the audit policies
    \item Get the registry value of the audit setting ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' and check if it is enabled
    \item Check if sysmon is installed and running
    \item Check if CAPI2 is enabled and has a minimum log size of 4MB
    \item Merge all returned hashtables from step 2-5 to one hashtable
    \item Write the ''result\_audit\_policy.xml'' for further processing to PDF
    \item Get all events from ''System'' and ''Security'' event logs and write it uniquely to a temporary CSV
    \item Get all events from ''Application and Service'' event log and write it uniquely to a temporary CSV
    \item Compare the gathered events with the target lists of events (see ''\ref{MandatoryLogs} \nameref{MandatoryLogs}'')
    \item Create the result PDF
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{assets/modes/offline.png}
    \caption{Offline Mode}
\end{figure}
\begin{enumerate}
    \item The offline mode without parameter will check the audit policies and event logs with the supplied export files\footnote{All export files required must remain at the \textbf{-ImportPath}}
    \begin{enumerate}
        \item Get the audit policies from the supplied rsop.xml
        \item Analyse the audit policies
        \item Write the ''result\_audit\_policy.xml'' for further processing to PDF
        \item Compare the events form the supplied windowslogs.csv and appandservlogs.csv with the target lists of events
        \item Create the result PDF
    \end{enumerate}
    \item The offline mode with the parameter \lstinline|-AuditPolicies| will check the audit policies with the supplied export file
    \begin{enumerate}
        \item Get the audit policies from the supplied rsop.xml
        \item Analyse the audit policies
        \item Write the ''result\_audit\_policy.xml'' for further processing to PDF
        \item Create the result PDF
    \end{enumerate}
    \item The offline mode with the parameter \lstinline|-EventLogs| will check the event logs with the supplied files
    \begin{enumerate}
        \item Compare the events form the supplied windowslogs.csv and appandservlogs.csv with the target lists of events
        \item Create the result PDF
    \end{enumerate}
\end{enumerate}

\clearpage

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{assets/modes/grouppolicy.png}
    \caption{GroupPolicy Mode}
\end{figure}
\begin{enumerate}
    \item Get the audit policies from defined group policy which is stored in SYSVOL
    \item Analyse the audit policies
    \item Check if the audit setting ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' is enabled
    \item Merge the returned hashtables from step 2 and 3 to one hashtable
    \item Write the ''result\_audit\_policy.xml'' for further processing to PDF
    \item Create the result PDF and store it in the current path
\end{enumerate}

\clearpage

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{assets/modes/allgrouppolicies.png}
    \caption{AllGroupPolicies Mode}
\end{figure}
\begin{enumerate}
    \item Get all audit policies from all group policies, which are stored in SYSVOL, and loop for each through the following procedure:
    \begin{enumerate}
        \item Analyse the audit policies
        \item Check if the audit setting ''Audit: Force audit policy subcategory settings (Windows Vista or later) to override audit policy category settings'' is enabled
        \item Merge the returned hashtables from step 2 and 3 to one hashtable
        \item Write the ''result\_audit\_policy.xml'' for further processing to PDF
        \item Create the result PDF and store it in the current path
        \item Rename the created PDF- and XML-Files to its group policy name (e.g. \lstinline|results_TestPolicy.pdf| and \lstinline|result_audit_policies_TestPolicy.xml|)
    \end{enumerate}
\end{enumerate}